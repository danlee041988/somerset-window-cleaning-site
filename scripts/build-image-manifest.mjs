import { promises as fs } from 'fs'
import { join, relative } from 'path'
import { execFile } from 'child_process'
import { fileURLToPath } from 'url'

const root = process.cwd()
// Scan the main SWC photos directory recursively (includes `website-photos`)
const photosDir = join(root, 'public', 'images', 'photos')

function run(cmd, args) {
  return new Promise((resolve, reject) => {
    execFile(cmd, args, { windowsHide: true }, (err, stdout, stderr) => {
      if (err) return reject(err)
      resolve(stdout.toString())
    })
  })
}

async function listFiles(dir) {
  const out = []
  async function walk(d) {
    const entries = await fs.readdir(d, { withFileTypes: true })
    for (const e of entries) {
      const p = join(d, e.name)
      if (e.isDirectory()) await walk(p)
      else out.push(p)
    }
  }
  await walk(dir)
  return out
}

async function dim(path) {
  try {
    const out = await run('sips', ['-g', 'pixelWidth', '-g', 'pixelHeight', path])
    const w = Number((out.match(/pixelWidth: (\d+)/) || [])[1] || 0)
    const h = Number((out.match(/pixelHeight: (\d+)/) || [])[1] || 0)
    return { w, h }
  } catch {
    return { w: 0, h: 0 }
  }
}

function relPublic(p) {
  return '/' + relative(join(root, 'public'), p).replaceAll('\\', '/')
}

function byRatioDesc(a, b) { return (b.w / (b.h || 1)) - (a.w / (a.h || 1)) }

const SERVICE_KEYWORDS = {
  window: ['window', 'glass', 'frame'],
  gutter: ['gutter', 'downpipe'],
  conservatory: ['conservatory', 'roof'],
  solar: ['solar', 'panel'],
  fascias: ['fascia', 'soffit', 'pvc'],
  commercial: ['shop', 'office', 'commercial'],
}

async function main() {
  try {
    await fs.access(photosDir)
  } catch {
    console.error(`No photos directory at ${photosDir}. Skipping.`)
    process.exit(1)
  }

  const files = (await listFiles(photosDir))
    .filter(f => /\.(jpe?g|png|webp)$/i.test(f))

  const withMeta = await Promise.all(files.map(async f => {
    const { w, h } = await dim(f)
    return { path: f, rel: relPublic(f), w, h, name: f.toLowerCase() }
  }))

  const landscape = withMeta.filter(i => i.w >= i.h).sort(byRatioDesc)
  const portrait = withMeta.filter(i => i.h > i.w)

  // Prefer any image named with 'hero' or 'main' as the first hero image
  const HERO_IMAGES = []
  const heroNamed = landscape.find(i => i.name.includes('hero') || i.name.includes('main'))
  if (heroNamed) HERO_IMAGES.push(heroNamed.rel)
  const heroWide = landscape.filter(i => (i.w / (i.h || 1)) >= 1.7).map(i => i.rel)
  for (const rel of heroWide) {
    if (HERO_IMAGES.length >= 3) break
    if (!HERO_IMAGES.includes(rel)) HERO_IMAGES.push(rel)
  }
  if (HERO_IMAGES.length === 0 && landscape[0]) HERO_IMAGES.push(landscape[0].rel)

  const TEAM_IMAGES = portrait.slice(0, 4).map(i => i.rel)

  const GALLERY_IMAGES = withMeta.map(i => i.rel)

  const SERVICE_IMAGES = {}
  for (const [key, words] of Object.entries(SERVICE_KEYWORDS)) {
    const match = landscape.find(i => words.some(w => i.name.includes(w))) || landscape.shift()
    SERVICE_IMAGES[key] = match ? match.rel : ''
  }

  const out = `// Generated by scripts/build-image-manifest.mjs\n` +
`export const HERO_IMAGES = ${JSON.stringify(HERO_IMAGES, null, 2)}\n\n` +
`export const GALLERY_IMAGES = ${JSON.stringify(GALLERY_IMAGES, null, 2)}\n\n` +
`export const TEAM_IMAGES = ${JSON.stringify(TEAM_IMAGES, null, 2)}\n\n` +
`export const SERVICE_IMAGES = ${JSON.stringify(SERVICE_IMAGES, null, 2)}\n`

  await fs.writeFile(join(root, 'content', 'image-manifest.ts'), out)
  console.log('Wrote content/image-manifest.ts with', GALLERY_IMAGES.length, 'images')
}

main().catch(err => { console.error(err); process.exit(1) })
